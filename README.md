# Battle with Monsters: Применение Принципа Открытости/Закрытости (Open/Closed Principle)

## Описание проекта

Проект представляет собой текстовую игру **Battle with Monsters**, где игрок управляет бойцом и сражается с монстрами, используя различные типы оружия. Главная цель — закрепить понимание принципа открытости/закрытости (Open/Closed Principle), одного из пяти SOLID принципов объектно-ориентированного программирования.

### Что такое принцип Open/Closed?
Принцип гласит:
- **Открытость для расширения**: Можно добавлять новые функциональности.
- **Закрытость для модификации**: Существующий код не должен изменяться при добавлении новых возможностей.

В рамках этого проекта мы создадим механизм, который позволяет легко добавлять новые типы оружия без изменения существующего кода бойца или механизма боя.

---

## Задачи проекта

1. Разработать архитектуру игры, следуя принципу Open/Closed.
2. Реализовать возможность выбора оружия для бойца.
3. Создать механизм боя между бойцом и монстром.
4. Демонстрировать результат боя в консоли.

---

## Архитектура проекта

### 1. Абстрактный класс для оружия

Создаем абстрактный класс `Weapon`, содержащий метод `attack()`. Этот метод определяет способ атаки конкретного типа оружия.

```python
from abc import ABC, abstractmethod

class Weapon(ABC):
    @abstractmethod
    def attack(self):
        pass
```

---

### 2. Конкретные типы оружия

Реализуем несколько классов, унаследованных от `Weapon`. Каждый класс будет иметь свою уникальную реализацию метода `attack()`.

#### Меч (`Sword`)
```python
class Sword(Weapon):
    def attack(self):
        return "наносит удар мечом"
```

#### Лук (`Bow`)
```python
class Bow(Weapon):
    def attack(self):
        return "стреляет из лука"
```

#### Добавление нового оружия
Например, добавляем дубинку (`Club`):
```python
class Club(Weapon):
    def attack(self):
        return "ударяет дубинкой"
```

**Примечание:** При добавлении нового типа оружия не требуется изменять классы `Fighter` или `Monster`.

---

### 3. Класс `Fighter`

Класс `Fighter` представляет бойца. Он содержит поле для хранения текущего оружия и метод для его изменения.

```python
class Fighter:
    def __init__(self, name):
        self.name = name
        self.weapon = None

    def change_weapon(self, weapon: Weapon):
        self.weapon = weapon
        print(f"{self.name} выбрал {weapon.__class__.__name__}.")

    def attack_monster(self, monster):
        if not self.weapon:
            print(f"{self.name} не имеет оружия!")
            return

        action = self.weapon.attack()
        print(f"{self.name} {action}.")
        monster.take_damage()
```

---

### 4. Класс `Monster`

Класс `Monster` представляет монстра. Он содержит метод `take_damage()`, который обрабатывает полученный урон.

```python
class Monster:
    def __init__(self, health=100):
        self.health = health

    def take_damage(self):
        self.health -= 20
        if self.health <= 0:
            print("Монстр побежден!")
        else:
            print(f"У монстра осталось {self.health} здоровья.")
```

---

### 5. Реализация боя

Создаем функцию для демонстрации боя между бойцом и монстром.

```python
def battle(fighter, monster):
    while monster.health > 0:
        fighter.attack_monster(monster)
        if monster.health <= 0:
            break
```

---

## Пример работы программы

```python
if __name__ == "__main__":
    # Создаем бойца и монстра
    fighter = Fighter("Герой")
    monster = Monster()

    # Выбираем меч
    fighter.change_weapon(Sword())
    battle(fighter, monster)

    # Восстанавливаем здоровье монстра для следующего раунда
    monster.health = 100

    # Выбираем лук
    fighter.change_weapon(Bow())
    battle(fighter, monster)

    # Добавляем новое оружие (дубинку) без изменения существующего кода
    fighter.change_weapon(Club())
    battle(fighter, monster)
```

---

## Результат выполнения

```
Герой выбрал Sword.
Герой наносит удар мечом.
У монстра осталось 80 здоровья.
Герой наносит удар мечом.
У монстра осталось 60 здоровья.
Герой наносит удар мечом.
У монстра осталось 40 здоровья.
Герой наносит удар мечом.
У монстра осталось 20 здоровья.
Герой наносит удар мечом.
Монстр побежден!

Герой выбрал Bow.
Герой стреляет из лука.
У монстра осталось 80 здоровья.
Герой стреляет из лука.
У монстра осталось 60 здоровья.
Герой стреляет из лука.
У монстра осталось 40 здоровья.
Герой стреляет из лука.
У монстра осталось 20 здоровья.
Герой стреляет из лука.
Монстр побежден!

Герой выбрал Club.
Герой ударяет дубинкой.
У монстра осталось 80 здоровья.
Герой ударяет дубинкой.
У монстра осталось 60 здоровья.
Герой ударяет дубинкой.
У монстра осталось 40 здоровья.
Герой ударяет дубинкой.
У монстра осталось 20 здоровья.
Герой ударяет дубинкой.
Монстр побежден!
```

---

## Преимущества архитектуры

1. **Простота расширения**: Новые типы оружия можно добавлять, создавая новые классы, унаследованные от `Weapon`.
2. **Закрытость для модификации**: Классы `Fighter` и `Monster` не требуют изменений при добавлении новых типов оружия.
3. **Чистый код**: Архитектура соответствует принципам SOLID, что делает код более поддерживаемым и масштабируемым.

---

## Заключение

Проект **Battle with Monsters** успешно демонстрирует применение принципа Open/Closed в разработке игр. Благодаря грамотной архитектуре, основанной на абстракциях и наследовании, мы можем легко расширять функциональность игры, не нарушая существующий код. Это позволяет создавать более гибкие и масштабируемые решения в долгосрочной перспективе.
 
